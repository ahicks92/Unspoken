Python-specific Notes
==============================

The following are brief notes on Python-specific binding features and how the Libaudioverse API maps to Python.

Comparing Objects
--------------------

Libaudioverse objects are thin proxies over handles, with their global state stored elsewhre in the Libaudioverse module.
Consequently, you need to use `==`, not `is`.
`is` will work sometimes, but no guarantee is made that two node objects in different variables are the same proxy instance.

Properties
--------------------

Properties are bound as Python properties, set up so that you can simply set them as normal: `sine.frequency = 32.5`.
At the moment, however, using properties on the right hand side of `=` requires appending `.value`: `sine.frequency.value * 2`.
Furthermore, using operators such as `*=` must be performed as `sine.frequency.value *= 5`.
This restriction (and this section of the documentation) will disappear at some point in the near future, once properties properly overload the arithmetic operators.

Callbacks
--------------------

Callbacks are bound as `node.set_XXX_callback` for setting and `node.get_XXX_callback` from getting.
The getter will always return the same callable as passed to the setter.

The signature of callbacks is specified in the reference.
Python matches the C signature, save for the userdata argument.
Instead, you can pass any number of extra arguments to the setter.
Note that the first `n` positional arguments need to match what Libaudioverse expects, otherwise the C bindings will crash and burn inside the callback.

Python holds a strong reference to the last set callback object until Libaudioverse deletes the handle.
You can therefore use any callable safely.


Atomicity and Simulation Locking
----------------------------------------

instead of binding `Lav_simulationLock` and `Lav_simulationUnlock` directly, the simulation is a context manager.
Using a with statement will make everything inside it inaudible until the with statement ends.
They may be nested safely.

For example::

   with my_simulation:
       # some stuff

Note that all the concerns in the language-agnostic manual apply.
If you use the simulation as a context manager on more than one thread, it behaves exactly like a lock; furthermore, all Libaudioverse functions that use the simulation or objects created from it will block on any thread but the one currently inside the critical section.

name Conversion
----------------

The names for Libaudioverse objects can be seen in the API reference.
This section is provided in order to aid in translating examples in C to Python.
This module follows PEP8 in the external API.
The code decidedly does not, as it is generated from custom tools.

Python class names  are generated by taking the `Lav_OBJTYPE_FOOBAR` enum constants, stripping the `Lav_OBJTYPE_` prefix, and converting the rest to camelcase.

Enumerations are generated in a similar manner as objects: strip the `Lav_` prefix and convert the rest to camelcase.
The members have their common prefix stripped and are then converted to lowercase, in accordance with the PEP8 class member standards.
